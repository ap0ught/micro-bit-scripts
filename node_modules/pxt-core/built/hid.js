"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var HF2 = pxt.HF2;
var U = pxt.U;
var HID = undefined;
function getHID() {
    if (HID === undefined) {
        try {
            HID = require("node-hid");
        }
        catch (e) {
            pxt.log('node-hid failed to load, ignoring...');
            HID = null;
        }
    }
    return HID;
}
function listAsync() {
    for (var _i = 0, _a = getHF2Devices(); _i < _a.length; _i++) {
        var h = _a[_i];
        console.log(deviceInfo(h));
    }
    return Promise.resolve();
}
exports.listAsync = listAsync;
function serialAsync() {
    return hf2DeviceAsync()
        .then(function (d) {
        connectSerial(d);
    });
}
exports.serialAsync = serialAsync;
function hex(n) {
    return ("000" + n.toString(16)).slice(-4);
}
function deviceInfo(h) {
    return h.product + " (by " + h.manufacturer + " at USB " + hex(h.vendorId) + ":" + hex(h.productId) + ")";
}
exports.deviceInfo = deviceInfo;
function getHF2Devices() {
    var hid = getHID();
    if (!hid)
        return [];
    var devices = hid.devices();
    return devices.filter(function (d) { return (d.release & 0xff00) == 0x4200; });
}
exports.getHF2Devices = getHF2Devices;
function hf2ConnectAsync(path) {
    var h = new HF2.Wrapper(new HidIO(path));
    return h.reconnectAsync(true).then(function () { return h; });
}
exports.hf2ConnectAsync = hf2ConnectAsync;
var hf2Dev;
function hf2DeviceAsync(path) {
    if (path === void 0) { path = null; }
    if (!hf2Dev) {
        var devs = getHF2Devices();
        if (devs.length == 0)
            return Promise.reject(new HIDError("no devices found"));
        path = devs[0].path;
        hf2Dev = hf2ConnectAsync(path);
    }
    return hf2Dev;
}
exports.hf2DeviceAsync = hf2DeviceAsync;
function connectSerial(w) {
    process.stdin.on("data", function (buf) {
        w.sendSerialAsync(new Uint8Array(buf)).done();
    });
    w.onSerial = function (arr, iserr) {
        var buf = new Buffer(arr);
        if (iserr)
            process.stderr.write(buf);
        else
            process.stdout.write(buf);
    };
}
exports.connectSerial = connectSerial;
var HIDError = (function (_super) {
    __extends(HIDError, _super);
    function HIDError(m) {
        _super.call(this, m);
        this.message = m;
    }
    return HIDError;
}(Error));
exports.HIDError = HIDError;
var HidIO = (function () {
    function HidIO(path) {
        this.path = path;
        this.onData = function (v) { };
        this.onError = function (e) { };
        this.connect();
    }
    HidIO.prototype.connect = function () {
        var _this = this;
        var hid = getHID();
        U.assert(hid);
        this.dev = new HID.HID(this.path);
        this.dev.on("data", function (v) {
            //console.log("got", v.toString("hex"))
            _this.onData(new Uint8Array(v));
        });
        this.dev.on("error", function (v) { return _this.onError(v); });
    };
    HidIO.prototype.sendPacketAsync = function (pkt) {
        var _this = this;
        //console.log("SEND: " + new Buffer(pkt).toString("hex"))
        return Promise.resolve()
            .then(function () {
            var lst = [0];
            for (var i = 0; i < 64; ++i)
                lst.push(pkt[i] || 0);
            _this.dev.write(lst);
        });
    };
    HidIO.prototype.error = function (msg) {
        var fullmsg = "HID error on " + this.path + ": " + msg;
        console.error(fullmsg);
        throw new HIDError(fullmsg);
    };
    HidIO.prototype.reconnectAsync = function () {
        var _this = this;
        if (this.dev) {
            // see https://github.com/node-hid/node-hid/issues/61
            this.dev.removeAllListeners("data");
            this.dev.removeAllListeners("error");
            var pkt = new Uint8Array([0x48]);
            this.sendPacketAsync(pkt).catch(function (e) { });
        }
        return Promise.delay(100)
            .then(function () {
            if (_this.dev)
                _this.dev.close();
            _this.dev = null;
            _this.connect();
        });
    };
    return HidIO;
}());
exports.HidIO = HidIO;
